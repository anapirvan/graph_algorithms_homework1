\section*{Problem 1}
\vspace{-1.5ex}
\vspace{-2ex}

\subsection*{a)}
Let $T$ be a spanning tree of the graph $G(V, E)$. The set of back edges (edges that do not belong to the tree) is $A = E(G) \setminus E(T)$, with $|A| = m - n + 1$. Based on this, we define all cycles $C_i = {e_i} \cup P_T(x_i, y_i)$, where $e_i = (x_i, y_i)$, $e_i \in A$ is a back edge, and $P_T(x_i, y_i)$ is the unique path in the tree $T$ from vertex $x_i$ to vertex $y_i$.
\\[-1.5ex]
We want to show that the characteristic vectors $x^{C_1}, x^{C_2}, \dots, x^{C_{m - n + 1}}$ generate the subspace $U$ mentioned in the lecture exercise.

\begin{itemize}
\item ${x^{C_1}, x^{C_2}, \dots, x^{C_{m - n + 1}}}$ is linearly independent because:
For any $i, k \ne i$ with $1 \le i \le m - n + 1$, we have $x^{C_k}{e_k} = 1$ and $x^{C_i}{e_k} = 0$, since the edge $e_k$ belongs to only one cycle. Therefore, $\sum_{i=1, i \ne k}^{m - n + 1} \alpha_i x^{C_i}$ has the $e_k$ component equal to 0, while $x^{C_k}$ has the $e_k$ component equal to 1. Thus, $x^{C_k}$ cannot be expressed as a linear combination of the other vectors in the set.
\item $|{x^{C_1}, x^{C_2}, \dots, x^{C_{m - n + 1}}}| = m - n + 1$. Also, from the lecture we know that $\dim(U) = m - n + 1$.
\end{itemize}

From the above, it follows that ${x^{C_1}, x^{C_2}, \dots, x^{C_{m - n + 1}}}$ forms a basis for the subspace $U$, hence it generates $U$ (since $x^{C_1}, x^{C_2}, \dots, x^{C_{m - n + 1}} \in U$).

Now we know that any cycle can be built from the cycles generated by the back edges, so the answer will be the set of all edges that appear in the cycles generated by the back edges.
\\[-1.5ex]
An efficient algorithm that finds all these edges can be described as follows:
Perform a DFS traversal of the graph $G$ (starting from any vertex) and keep track of each nodeâ€™s parent in a vector. When reaching a node that has already been visited and is not the parent of the current node, we have found a back edge and therefore a cycle. We then follow the path in the tree between the endpoints of that back edge and add every edge from this path, together with the back edge, to the result. The time complexity will be $O(n*m)$, since all nodes are traversed in $O(n+m)$, and for each back edge (of which there are $m - n + 1 = O(m)$) we traverse a path of length $O(n)$.
\[-1.5ex]

\begin{algorithmic}
\State $edges \gets \emptyset$
\For{$i$ in $1,n$}
\State $previous[i] \gets -1$
\State $visited[i] \gets 0$
\EndFor

\Function{dfs}{$x$}
\State $visited[x] \gets 1$
\For{$y$ in $adj[x]$}
\If{$visited[y] == 0$}
\State $previous[y] \gets x$
\State \Call{dfs}{$y$}
\ElsIf{$y \ne previous[x]$}
\State $edges \gets edges \cup (x, y)$
\State $z \gets x$
\While{$previous[z] \ne -1$ and $previous[z] \ne y$}
\State $edges \gets edges \cup (previous[z], z)$
\State $z \gets previous[z]$
\EndWhile
\EndIf
\EndFor
\EndFunction
\State \Call{dfs}{$1$}
\end{algorithmic}

\subsection*{b)}
The above algorithm can be optimized to $O(n+m)$ time complexity as follows:
\begin{itemize}
\item Use an array to store the discovery times of the nodes.
\item Use a stack of edges to keep track of the path from the root of the spanning tree to the current node during traversal.
\item When a back edge is found, pop the edges that form the cycle from $x$ to $y$ from the stack and add them to the result, stopping based on the discovery times.
\end{itemize}

Each edge will be pushed to and popped from the stack exactly once. The $O(n+m)$ complexity is optimal, as it matches the lower bound for traversing a graph.